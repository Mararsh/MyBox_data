 <html> 
<head> 
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<style type="text/css">
		body {font-size:14px;}
		p.p1 {text-indent: 0em; font-size:16px;font-weight:bold}
		p.p2 {text-indent: 0em; font-size:14px;font-weight:bold}
		.paragraph {text-indent: 2em; font-size:14px;}
		ul.inside {list-style-position: inside; text-indent: 2em;}
	</style>
</head> 
<body> 

<a href="https://github.com/Mararsh/Vegetables_Garden">返回</a>	
<h2 align="center">实时数据流系统中避免"过期读"的性能优化方案</h2>
<P class="p1">问题的背景</P>
	<div class="paragraph">
		<p>实时数据流系统具有以下特点：</p>
			<ul  class="inside">
				<li>新数据源源不断生成。在负载较大的系统中，新数据的生成速度可达每秒上千上万条。</li>
				<li>随着时间积累出规模巨大的历史数据。</li>
				<li>快速累计的数据往往只增删、不修改。</li>
				<li>通常以数据生成的时间戳为关键查询条件。</li>				
			</ul>
		<p>典型的实时数据流系统包括：工业数据监测系统、传感器检测系统、位置服务系统、电子商务网站、电信收费系统、服务器日志。</p>
	</div>

<P class="p1">问题是什么</P>		
	<div class="paragraph">
		<p>对于实时数据流系统，数据的汇集、存储、转换、查询、统计都面临性能优化的需求。在实际的系统实现中，性能优化的技术体现的多个层面：</p>
			<ul  class="inside">
				<li>读写分离。利用主从数据库架构，实现写操作在主库而读操作在从库、避免锁操作带来的延迟。</li>
				<li>缓存。无论前端页面加载还是后端持久化事务处理，都有很多缓存技术可用。</li>				
				<li>延迟加载。只获取和展示必要的数据，可以减少数据的读取、传输、存储的量。</li>
			</ul>
		<p>同时采用以上技术时，可能碰到“过期读”（stale read）问题。例如，持久化事务的缓存会使从库无法实时读到数据更新：一条数据被修改了，它的主库中的持久化对象被在缓存中更新，但是并没有实时写入数据库，这样从库就不知道此条数据已被更新，从而读写分离的业务就会查询到旧数据。矛盾就在于：缓存使得主从数据没有同步。</p>
		<p>怎么才能避免“过期读”、同时又不放弃所有的性能优化技术呢？</p>
	</div>

<P class="p1">解决问题的方案</P>		
	<div class="paragraph">
		<p>通过实践得知：当创建或者删除数据时，持久化对象必然同步数据库。如果一种数据只增删不更改，则这类数据不存在“过期读”的问题。所以，解决方案是：对系统中的数据加以分类，对只增删的数据做读写分离，对会发生更改的数据要么只在主库上操作、要么关闭持久化层的缓存。</p>
		<p>幸运的是，实时数据流系统中的关键数据通常是只增删的。以定位服务系统为例，大量积累的数据是坐标值，一旦记录不再更改，则可以做到读写分离加缓存同时避免过期读；系统中的用户管理数据是实时变动的，读写均在主库上，由于数据规模有限、对性能影响并不大。</p>
	</div>
	
<a href="https://github.com/Mararsh/Vegetables_Garden">返回</a>	
</body> 
</html>